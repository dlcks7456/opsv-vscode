{
  "qamode": {
    "prefix": "pre-qa",
    "scope": "js",
    "body": [
      "(()=>{",
      "  const script = document.createElement('script');",
      "  script.src = 'https://cdn.jsdelivr.net/gh/dlcks7456/sndutils@main/js/qaCodes.js';",
      "  script.onload = function () {",
      "      qaMode({ defaultMode: true });",
      "  };",
      "  script.onerror = function () {",
      "      console.error('Failed to load qaCodes.js');",
      "  };",
      "  document.head.appendChild(script);",
      "})()"
    ],
    "description": "[사전 로직] qaMode 설정"
  },
  "dataspringRedirect": {
    "prefix": "dataspring",
    "scope": "js",
    "body": [
      "// DataSpring: ACCESS_KEY",
      "const accessKey = '${1:엑세스 키}';",
      "const grpid = '${2:국가 코드}';",
      "const redirect = {",
      "  screenout: `https://survey1.datadata.co.kr/?ACCESS_KEY=\\${accessKey}&grpid=\\${grpid}&Q=STID&UID=\\${EID}&status=scrout`,",
      "  complete:  `https://survey1.datadata.co.kr/?ACCESS_KEY=\\${accessKey}&grpid=\\${grpid}&Q=STID&UID=\\${EID}&status=comp`,",
      "  quotafull: `https://survey1.datadata.co.kr/?ACCESS_KEY=\\${accessKey}&grpid=\\${grpid}&Q=STID&UID=\\${EID}&status=quotafull`,",
      "};"
    ],
    "description": "[리다이렉트] 데이터스프링"
  },
  "dynataRedirect": {
    "prefix": "dynata",
    "scope": "js",
    "body": [
      "// Dynata",
      "const redirect = {",
      "  screenout: `https://dkr1.ssisurveys.com/projects/end?rst=2&psid=\\${EID}`,",
      "  complete:  `https://dkr1.ssisurveys.com/projects/end?rst=1&psid=\\${EID}`,",
      "  quotafull: `https://dkr1.ssisurveys.com/projects/end?rst=3&psid=\\${EID}`,",
      "};"
    ],
    "description": "[리다이렉트] 다이나타"
  },
  "purespectrumRedirect": {
    "prefix": "purespectrum",
    "scope": "js",
    "body": [
      "// PureSpectrum: ps_hash",
      "const psHash = '${1:ps_hash}';",
      "const redirect = {",
      "  screenout: `https://spectrumsurveys.com/surveydone?st=18&transaction_id=\\${EID}&ps_hash=\\${psHash}`,",
      "  complete:  `https://spectrumsurveys.com/surveydone?st=21&transaction_id=\\${EID}&ps_hash=\\${psHash}`,",
      "  quotafull: `https://spectrumsurveys.com/surveydone?st=17&transaction_id=\\${EID}&ps_hash=\\${psHash}`,",
      "};"
    ],
    "description": "[리다이렉트] 퓨어스펙트럼"
  },
  "tolunaRedirect": {
    "prefix": "toluna",
    "scope": "js",
    "body": [
      "// Toluna: sname",
      "const sname = '${1:sname}';",
      "const redirect = {",
      "  screenout: `https://ups.surveyrouter.com/TrafficUI/MSCUI/SOTerminated.aspx?sname=\\${sname}&gid=\\${EID}`,",
      "  complete:  `https://ups.surveyrouter.com/TrafficUI/MSCUI/SOQualified.aspx?sname=\\${sname}&gid=\\${EID}`,",
      "  quotafull: `https://ups.surveyrouter.com/TrafficUI/MSCUI/SOQuotafull.aspx?sname=\\${sname}&gid=\\${EID}`,",
      "};"
    ],
    "description": "[리다이렉트] 톨루나"
  },
  "quotaSetting": {
    "prefix": "quota",
    "scope": "js",
    "body": [
      "const redirect = {",
      "  // Redirect URL",
      "  screenout: `https://SCREENOUT_URL.com`,",
      "  complete: `https://COMPLETE_URL.com`,",
      "  quotafull: `https://QUOTAFULL_URL.com`,",
      "};",
      "",
      "/* Quota */",
      "const quotaFlag = \\$(`#quotaFlag`);",
      "const redirectUrl = \\$(`#redirectUrl`);",
      "",
      "/* Default Screen Out Setting */",
      "quotaFlag.val(1);",
      "redirectUrl.val(redirect.screenout);",
      "setAnswer(1, ValueType.TEXT, 1, true);",
      "",
      "window.quotaFull = () => {",
      "  /* -- Quotas -- */",
      "  const gender = getAnswerSet(GENDER_QID);",
      "  const age = getAnswerSet(AGE_QID);",
      "",
      "  const quotas = {",
      "    // 모든 쿼터(싱글/복수)를 quotas 객체에 담아서 처리",
      "    genderQuota: {",
      "      '남자': gender.exists([1]),",
      "      '여자': gender.exists([2]),",
      "    },",
      "    ageQuota: {",
      "      '20대': age.val() >= 20 && age.val() <= 29,",
      "      '30대': age.val() >= 30 && age.val() <= 39,",
      "      '40대': age.val() >= 40 && age.val() <= 49,",
      "      '50대': age.val() >= 50 && age.val() <= 59,",
      "    },",
      "    genderByAgeQuota: {",
      "      '남자_20대': gender.exists([1]) && age.val() >= 20 && age.val() <= 29,",
      "      '남자_30대': gender.exists([1]) && age.val() >= 30 && age.val() <= 39,",
      "      '남자_40대': gender.exists([1]) && age.val() >= 40 && age.val() <= 49,",
      "      '남자_50대': gender.exists([1]) && age.val() >= 50 && age.val() <= 59,",
      "      '여자_20대': gender.exists([2]) && age.val() >= 20 && age.val() <= 29,",
      "      '여자_30대': gender.exists([2]) && age.val() >= 30 && age.val() <= 39,",
      "      '여자_40대': gender.exists([2]) && age.val() >= 40 && age.val() <= 49,",
      "      '여자_50대': gender.exists([2]) && age.val() >= 50 && age.val() <= 59,",
      "    },",
      "  };",
      "  /* ---- */",
      "",
      "  const quotaFull = quotaCheck(quotas);",
      "",
      "  if (quotaFull) {",
      "    quotaFlag.val(3); // Quota Full",
      "    setAnswer(1, ValueType.TEXT, 3, true);",
      "    redirectUrl.val(redirect.quotafull);",
      "    console.log(`> QUOTA FULL`, redirectUrl.val());",
      "    return false;",
      "  }",
      "",
      "  quotaFlag.val(2); // Complete",
      "  redirectUrl.val(redirect.complete);",
      "  setAnswer(1, ValueType.TEXT, 2, true);",
      "  console.log(`> COMPLETE`, redirectUrl.val());",
      "",
      "  return true;",
      "};",
      "",
      "function quotaCheck(quotas) {",
      "  for (const quota of Object.entries(quotas)) {",
      "    const [quotaName, quotaCondition] = quota;",
      "    const passFlag = Object.entries(quotaCondition).some(",
      "      ([cell, cond]) => cond",
      "    );",
      "    if (!passFlag) {",
      "      console.log(`⚠️ \\${quotaName}`);",
      "      return true;",
      "    }",
      "",
      "    Object.entries(quotaCondition).forEach(([cell, cond]) => {",
      "      if (cond) {",
      "        console.log(`✅ \\${quotaName} - \\${cell}`);",
      "      }",
      "    });",
      "  }",
      "  return false;",
      "}"
    ],
    "description": "[리다이렉트] 톨루나"
  },

  "multiTextAtLeast1": {
    "prefix": "multi-text-1",
    "scope": "js",
    "body": [
      "(() => {",
      "  const errorMessages = {",
      "    empty: '첫번째 칸은 반드시 입력해주세요.',",
      "    outOfOrder: '입력 칸을 순서대로 사용해주세요.',",
      "    duplicate: '중복된 응답이 있습니다.',",
      "  };",
      "",
      "  const question = \\$(`#survey\\${cur}`);",
      "  const nextBtn = question.find('.next-btn-wrapper');",
      "  question.find('.answer').hide();",
      "  nextBtn.attr('onclick', null);",
      "",
      "  const raw = question.find(`.multi input`);",
      "  const rawIndex = [...raw].map((e) => Number(e.id.replace('x', ''))).sort((a, b) => a - b);",
      "",
      "  const inputs = question.find(`.multi input`);",
      "",
      "  inputs.off('keyup change').on('keyup change', (e) => {",
      "    const index = inputs.index(e.currentTarget);",
      "    const prevInputs = inputs.slice(0, index);",
      "",
      "    const hasEmptyPrev = [...prevInputs].some((input) => input.value.trim() === '');",
      "",
      "    if (hasEmptyPrev) {",
      "      e.currentTarget.value = '';",
      "      if (index > 0) {",
      "        const emptyInputs = [...prevInputs].findIndex(input => input.value.trim() === '');",
      "        if (emptyInputs !== -1) {",
      "          inputs.eq(emptyInputs).focus();",
      "        } else {",
      "          inputs.eq(index - 1).focus();",
      "        }",
      "      }",
      "",
      "      alert(errorMessages.outOfOrder);",
      "    }",
      "  });",
      "",
      "  nextBtn.click(() => {",
      "    const inputs = question.find(`.multi input`);",
      "    if (inputs.eq(0).val().trim() === '') {",
      "      alert(errorMessages.empty);",
      "      inputs.eq(0).focus();",
      "      return;",
      "    }",
      "",
      "    const values = [...inputs].filter((e) => e.value.trim() !== '').map((e) => e.value);",
      "    if (new Set(values).size !== values.length) {",
      "      alert(errorMessages.duplicate);",
      "      return;",
      "    }",
      "",
      "    const answer = rawIndex.map((e) => \\$(`#survey\\${cur} #x\\${e}`).val()).join('|');",
      "    \\$(`#answer\\${cur}`).val(answer);",
      "    goNext();",
      "  });",
      "",
      "  return true;",
      "})()"
    ],
    "description": "[복수 주관식] 첫번째 칸 필수/순서대로 응답"
  },
  "multiTextAllAnswer": {
    "prefix": "multi-text-all",
    "scope": "js",
    "body": [
      "(() => {",
      "  const errorMessages = {",
      "    empty: '빈 칸 없이 응답을 입력해 주세요.',",
      "    duplicate: '중복된 응답이 있습니다.',",
      "  };",
      "",
      "  const question = \\$(`#survey\\${cur}`);",
      "  const nextBtn = question.find('.next-btn-wrapper');",
      "  question.find('.answer').hide();",
      "  nextBtn.attr('onclick', null);",
      "",
      "  const raw = question.find(`.multi input`);",
      "  const rawIndex = [...raw].map((e) => Number(e.id.replace('x', ''))).sort((a, b) => a - b);",
      "",
      "  nextBtn.click(() => {",
      "    const inputs = [...question.find(`.multi input`)].filter((input) => !input.disabled);",
      "    if ([...inputs].some((e) => e.value.trim() === '')) {",
      "      alert(errorMessages.empty);",
      "      return;",
      "    }",
      "",
      "    const values = [...inputs].map((e) => e.value);",
      "    if (new Set(values).size !== values.length) {",
      "      alert(errorMessages.duplicate);",
      "      return;",
      "    }",
      "",
      "    const answer = rawIndex.map((e) => \\$(`#survey\\${cur} #x\\${e}`).val()).join('|');",
      "    \\$(`#answer\\${cur}`).val(answer);",
      "    goNext();",
      "  });",
      "",
      "  return true;",
      "})()"
    ],
    "description": "[복수 주관식] 모두 응답"
  },
  "multiNumber": {
    "prefix": "multi-num",
    "scope": "js",
    "body": [
      "(() => {",
      "  let min = 0;",
      "  let max = 100;",
      "  let total = null;",
      "",
      "  const errorMessages = {",
      "    empty: '모든 항목을 입력해주세요.',",
      "    range: `\\${min}~\\${max} 사이의 값을 입력해주세요.`,",
      "    total: `총합이 \\${total}이 되어야 합니다.`,",
      "  };",
      "",
      "  const question = \\$(`#survey\\${cur}`);",
      "  const nextBtn = question.find('.next-btn-wrapper');",
      "  question.find('.answer').hide();",
      "  question.find('.question-foot').hide();",
      "  nextBtn.attr('onclick', null);",
      "",
      "  const raw = question.find(`.multi input`);",
      "  const rawIndex = [...raw].map((e) => Number(e.id.replace('x', ''))).sort((a, b) => a - b);",
      "",
      "  if (total !== null) {",
      "    question.on('keyup', (e) => {",
      "      const totalInput = question.find('#xTotal');",
      "      const inputs = question.find(`.multi input`);",
      "      const sum = [...inputs].reduce((acc, cur) => acc + Number(cur.value), 0);",
      "      totalInput.val(sum);",
      "    });",
      "  }",
      "",
      "  nextBtn.click(() => {",
      "    const inputs = [...question.find(`.multi input`)].filter((input) => !input.disabled);",
      "",
      "    // Empty",
      "    if (inputs.some((e) => \\$(e).val() === '')) {",
      "      alert(errorMessages.empty);",
      "      return;",
      "    }",
      "",
      "    // Range",
      "    if (inputs.some((e) => Number(e.value) < min || Number(e.value) > max)) {",
      "      alert(errorMessages.range);",
      "      return;",
      "    }",
      "",
      "    // Total",
      "    if (total !== null && inputs.reduce((acc, cur) => acc + Number(cur.value), 0) !== total) {",
      "      alert(errorMessages.total);",
      "      return;",
      "    }",
      "",
      "    const answer = rawIndex.map((e) => \\$(`#survey\\${cur} #x\\${e}`).val()).join('|');",
      "    \\$(`#answer\\${cur}`).val(answer);",
      "    goNext();",
      "  });",
      "",
      "  return true;",
      "})()"
    ],
    "description": "[복수 숫자형] 유효성 검증"
  },
  "multiNumberWithStep": {
    "prefix": "multi-num-step",
    "scope": "js",
    "body": [
      "(() => {",
      "  let min = 0;",
      "  let max = 100;",
      "  let step = 10;",
      "  let total = 100;",
      "",
      "  const errorMessages = {",
      "    empty: '모든 항목을 입력해주세요.',",
      "    range: `\\${min}~\\${max} 사이의 값을 입력해주세요.`,",
      "    total: `총합이 \\${total}이 되어야 합니다.`,",
      "    step: `\\${step}의 배수로 입력해주세요.`,",
      "  };",
      "",
      "  const question = \\$(`#survey\\${cur}`);",
      "  const nextBtn = question.find('.next-btn-wrapper');",
      "  question.find('.answer').hide();",
      "  question.find('.question-foot').hide();",
      "  nextBtn.attr('onclick', null);",
      "",
      "  const raw = question.find(`.multi input`);",
      "  const rawIndex = [...raw].map((e) => Number(e.id.replace('x', ''))).sort((a, b) => a - b);",
      "",
      "  if (total !== null) {",
      "    question.on('keyup', (e) => {",
      "      const totalInput = question.find('#xTotal');",
      "      const inputs = question.find(`.multi input`);",
      "      const sum = [...inputs].reduce((acc, cur) => acc + Number(cur.value), 0);",
      "      totalInput.val(sum);",
      "    });",
      "  }",
      "",
      "  nextBtn.click(() => {",
      "    const inputs = [...question.find(`.multi input`)].filter((input) => !input.disabled);",
      "",
      "    // Empty",
      "    if (inputs.some((e) => \\$(e).val() === '')) {",
      "      alert(errorMessages.empty);",
      "      return;",
      "    }",
      "",
      "    // Range",
      "    if (inputs.some((e) => Number(e.value) < min || Number(e.value) > max)) {",
      "      alert(errorMessages.range);",
      "      return;",
      "    }",
      "",
      "    // Step",
      "    if (inputs.some((e) => Number(e.value) % step !== 0)) {",
      "      alert(errorMessages.step);",
      "      return;",
      "    }",
      "",
      "    // Total",
      "    if (total !== null && inputs.reduce((acc, cur) => acc + Number(cur.value), 0) !== total) {",
      "      alert(errorMessages.total);",
      "      return;",
      "    }",
      "",
      "    const answer = rawIndex.map((e) => \\$(`#survey\\${cur} #x\\${e}`).val()).join('|');",
      "    \\$(`#answer\\${cur}`).val(answer);",
      "    goNext();",
      "  });",
      "",
      "  return true;",
      "})()"
    ],
    "description": "[복수 숫자형] 유효성 검증/단위(step) 포함"
  },
  "multiCond": {
    "prefix": "multi-cond",
    "scope": "js",
    "body": [
      "(()=>{",
      "    const question = \\$(`#survey\\${cur}`);",
      "    const multis = question.find('.multi');",
      "    const base = getAnswerSet();",
      "    multis.hide();",
      "    multis.find('input, select').prop('disabled', true);",
      "    base.answers.forEach((answer) => {",
      "        const code = answer.value.order;",
      "        const target = question.find(`.multi-\\${code}`);",
      "        target.show();",
      "        target.find('input, select').prop('disabled', false);",
      "    });",
      "    return true;",
      "})()"
    ],
    "description": "[복수 주관식/숫자형] Hide/Show\n- multi snippet에 추가하는 코드\n-조건에 따라 변경 필요"
  },
  "multiDropdown": {
    "prefix": "multi-drop",
    "scope": "js",
    "body": [
      "(() => {",
      "  const duplicateCheck = false;",
      "  const errorMessages = {",
      "    empty: '모든 항목을 응답해주세요.',",
      "    duplicate: '중복된 항목이 있습니다.',",
      "  };",
      "  const question = \\$(`#survey\\${cur}`);",
      "  const nextBtn = question.find('.next-btn-wrapper');",
      "  question.find('.answer').hide();",
      "  question.find('.question-foot').hide();",
      "  nextBtn.attr('onclick', null);",
      "",
      "  const raw = question.find(`.multi select`);",
      "  const rawIndex = [...raw].map((e) => Number(e.id.replace('x', ''))).sort((a, b) => a - b);",
      "",
      "  nextBtn.click(() => {",
      "    // Empty",
      "    const selects = [...question.find(`.multi select`)].filter((select) => !select.disabled);",
      "    if (selects.some((select) => select.value === '')) {",
      "      alert(errorMessages.empty);",
      "      return;",
      "    }",
      "",
      "    // Duplicate",
      "    const values = [...selects].map((select) => select.value);",
      "    if (duplicateCheck && values.some((value, index) => values.indexOf(value) !== index)) {",
      "      alert(errorMessages.duplicate);",
      "      return;",
      "    }",
      "",
      "    const answer = rawIndex.map((e) => \\$(`#survey\\${cur} #x\\${e}`).val()).join('|');",
      "    \\$(`#answer\\${cur}`).val(answer);",
      "    goNext();",
      "  });",
      "",
      "  return true;",
      "})()"
    ],
    "description": "[복수 드롭다운] 유효성 검증 / 중복 검사"
  },
  "questionGroupEachQuestion": {
    "prefix": "pre-q-rot",
    "scope": "js",
    "body": ["setGroupSet('group${1}', [QuestionNumbers].map(qid => new Range(qid, qid)));", "", "initGroups();"],
    "description": "[사전 로직] 문항 그룹 로테이션:1문항 씩"
  },
  "questionGroupInRange": {
    "prefix": "pre-q-rot-range",
    "scope": "js",
    "body": [
      "setGroupSet('group${1}', [[${2:start}, ${3:end}]].map(([start, end]) => new Range(start, end)));",
      "",
      "initGroups();"
    ],
    "description": "[사전 로직] 문항 그룹 로테이션:Range"
  },
  "ratingHandlerFunction": {
    "prefix": "pre-rating",
    "scope": "js",
    "body": [
      "// ratingHandler({ reverse: true, showValue: true});",
      "window.rating = (obj) => {",
      "  return ratingHandler({ ...obj, qNum: cur });",
      "};",
      "",
      "function ratingHandler({",
      "  reverse = false,",
      "  showValue = false,",
      "  qNum = null,",
      "  balance = false,",
      "  format = null,",
      "  colSpan = false,",
      "  colSize = '45%',",
      "}) {",
      "  try {",
      "    const surveyForm = document.querySelector('#survey_form');",
      "    let ratings = [];",
      "    if (qNum === null) {",
      "      const allQuestions = surveyForm.querySelectorAll('.survey');",
      "      ratings = [...allQuestions].filter((question) => [5, 9].includes(Number(question.querySelector('#type').value)));",
      "    } else {",
      "      if (Array.isArray(qNum)) {",
      "        ratings = qNum.map((q) => surveyForm.querySelectorAll(`#survey\\${q}`));",
      "      } else {",
      "        ratings = [surveyForm.querySelector(`#survey\\${qNum}`)];",
      "      }",
      "    }",
      "",
      "    ratings.forEach((rating) => {",
      "      const cells = rating.querySelectorAll('.answer-eval-wrapper tbody tr:first-child td');",
      "      const score = cells.length;",
      "      const ratingType = Number(rating.querySelector('#type').value);",
      "      const tableFlag = score > 7;",
      "",
      "      let ratingCSS = '';",
      "      let tableCellCSS = '';",
      "",
      "      const maxScore = cells.length;",
      "      const halfScore = maxScore % 2 === 0 ? Math.floor(maxScore / 2) : Math.floor(maxScore / 2) + 1;",
      "",
      "      if (ratingType === 5) {",
      "        tableCellCSS += `",
      "              td {",
      "                  width: 100%;",
      "              }`;",
      "",
      "        if (reverse) {",
      "          ratingCSS += `",
      "              #\\${rating.id} .answer-eval-wrapper {",
      "                  tbody tr {",
      "                      \\${tableFlag ? 'display: flex;' : ''}",
      "                      flex-direction: row-reverse;",
      "",
      "                      \\${tableFlag ? tableCellCSS : ''}",
      "",
      "                      &:last-child {",
      "                        td:first-child {",
      "                          text-align: right!important;",
      "                        }",
      "                        td:last-child {",
      "                          text-align: left!important;",
      "                        }",
      "                      }",
      "                  }",
      "              }",
      "              `;",
      "        }",
      "",
      "        if ((showValue || balance) && !tableFlag) {",
      "          ratingCSS += `",
      "                  #\\${rating.id} table tbody tr:first-child td {",
      "                      position: relative;",
      "                  }",
      "",
      "                  #\\${rating.id} .cell-value {",
      "                      position: absolute;",
      "                      bottom: -60%;",
      "                      left: 50%;",
      "                      transform: translate(-50%, -50%);",
      "                      font-size: 0.7rem;",
      "                      z-index: 999;",
      "                      color: #2b2a2a;",
      "                      pointer-events: none;",
      "                      font-weight: bold;",
      "                      width: 100%;",
      "                      text-align: center;",
      "                  }`;",
      "",
      "          cells.forEach((cell) => {",
      "            let cellValue = Number(cell.querySelector('input').value);",
      "            if (balance) {",
      "              cellValue = Math.abs(cellValue - halfScore) + (cellValue <= halfScore && maxScore % 2 === 0 ? 1 : 0);",
      "            }",
      "            const valueLabel = document.createElement('div');",
      "            valueLabel.classList.add('cell-value');",
      "            valueLabel.textContent = `[\\${cellValue}점]`;",
      "            if (format !== null) {",
      "              valueLabel.textContent = format.replace('%d', cellValue);",
      "            }",
      "            cell.appendChild(valueLabel);",
      "          });",
      "        }",
      "      }",
      "",
      "      if (ratingType === 9) {",
      "        ratingCSS += `",
      "        #\\${rating.id} .answer .answer-wrapper {",
      "          display: flex;",
      "          flex-direction: column-reverse;",
      "        }",
      "        `;",
      "      }",
      "",
      "      const styleTag = document.createElement('style');",
      "      styleTag.textContent = ratingCSS;",
      "      rating.insertBefore(styleTag, rating.firstChild);",
      "",
      "      if (colSpan) {",
      "        const centerWrapper = rating.querySelector(`td.eval-text-wrapper[align='center']`);",
      "        const leftWrapper = rating.querySelector(`td.eval-text-wrapper[align='left']`);",
      "        const rightWrapper = rating.querySelector(`td.eval-text-wrapper[align='right']`);",
      "        const allWrappers = rating.querySelectorAll('td.eval-text-wrapper');",
      "",
      "        if (maxScore % 2 === 0) {",
      "          centerWrapper.style.display = 'none';",
      "          centerWrapper.setAttribute('colspan', 0);",
      "        } else {",
      "          centerWrapper.setAttribute('colspan', 1);",
      "        }",
      "",
      "        const spanCount = maxScore % 2 === 0 ? halfScore : halfScore - 1;",
      "",
      "        leftWrapper.setAttribute('colspan', spanCount);",
      "        rightWrapper.setAttribute('colspan', spanCount);",
      "        [...allWrappers].forEach((wrapper) => {",
      "          wrapper.style.flexBasis = colSize;",
      "          wrapper.style.wordBreak = 'keep-all';",
      "        });",
      "      }",
      "    });",
      "  } catch (error) {",
      "    console.error('ratingHandler error:', error);",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 평가형 문항 역순/코드 제시"
  },
  "optionHandler": {
    "prefix": "pre-opt",
    "scope": "js",
    "body": [
      "window.hide = (options, cond = true, qnum = null) => {",
      "  if (qnum === null) {",
      "    qnum = cur;",
      "  }",
      "",
      "  if (cond) {",
      "    return hideOption(qnum, options);",
      "  } else {",
      "    return showOption(qnum, options);",
      "  }",
      "};",
      "",
      "window.show = (options, cond = true, qnum = null) => {",
      "  if (qnum === null) {",
      "    qnum = cur;",
      "  }",
      "",
      "  if (cond) {",
      "    return showOption(qnum, options);",
      "  } else {",
      "    return hideOption(qnum, options);",
      "  }",
      "};",
      "",
      "window.disabled = (options, cond = true, qnum = null) => {",
      "  try {",
      "    if (qnum === null) {",
      "      qnum = cur;",
      "    }",
      "",
      "    const qname = `#survey\\${qnum}`;",
      "    const currentQuestion = document.querySelector(qname);",
      "",
      "    if (!currentQuestion.querySelector('style[data-disabled-style]')) {",
      "      const disabledCSS = `",
      "      <style data-disabled-style>",
      "      \\${qname} .answer-choice-wrapper {",
      "          transition: opacity 0.5s ease;",
      "      }",
      "      .disabled-logic {",
      "          pointer-events: none!important;",
      "          opacity: 0.3!important;",
      "      }",
      "      </style>`;",
      "      currentQuestion.insertAdjacentHTML('beforeend', disabledCSS);",
      "    }",
      "",
      "    if (!Array.isArray(options)) {",
      "      options = [options];",
      "    }",
      "",
      "    options.forEach((option) => {",
      "      const optionType = typeof option;",
      "      const targetElement = optionType === 'number' ? `#answer\\${qnum}-\\${option}` : option;",
      "      const targetNode = document.querySelector(`\\${qname} \\${targetElement}`);",
      "      const targetOption = optionType === 'number' ? targetNode.parentNode : targetNode;",
      "",
      "      if (cond) {",
      "        targetOption.classList.add('disabled-logic');",
      "        targetNode.readOnly = true;",
      "      } else {",
      "        targetOption.classList.remove('disabled-logic');",
      "        targetNode.readOnly = false;",
      "      }",
      "",
      "      if (optionType !== 'number') {",
      "        const childInputs = targetNode.querySelectorAll('input');",
      "        childInputs.forEach((input) => {",
      "          input.readOnly = cond;",
      "        });",
      "      }",
      "    });",
      "  } catch (error) {",
      "    console.error(`Error in optionHandler (disabled):`, error);",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] hide/show/disabled"
  },
  "thisOrThatFunction": {
    "prefix": "pre-tot",
    "scope": "js",
    "body": [
"window.thisOrThat = (groups = {}, qnum = null) => {",
"  try {",
"    if (qnum === null) qnum = cur;",
"    if (Object.keys(groups).length === 0) return true;",
"",
"    const questionId = `#survey\\${qnum}`;",
"    const question = document.querySelector(questionId);",
"    const maxAnswer = Number(question.querySelector('#max').value);",
"",
"    if (!question.querySelector('style[data-this-that-style]')) {",
"      const thisThatCSS = `",
"        <style data-this-that-style>",
"        \\${questionId} .answer-choice-wrapper {",
"          transition: opacity 0.5s ease;",
"        }",
"        </style>`;",
"      question.insertAdjacentHTML('beforeend', thisThatCSS);",
"    }",
"",
"    const optionMap = {};",
"    const groupInfo = {};",
"",
"    Object.entries(groups).forEach(([group, arr]) => {",
"      if (!Array.isArray(arr)) return;",
"",
"      if (arr.every((v) => typeof v === 'number')) {",
"        groupInfo[group] = { type: 'exclusive', sets: [arr] };",
"        mapOptionsToGroup(arr, group, 0);",
"      } else if (arr.length === 2) {",
"        const agroup = arr[0];",
"        const bgroup = arr[1];",
"        const sets = [Array.isArray(agroup) ? agroup : [agroup], Array.isArray(bgroup) ? bgroup : [bgroup]];",
"        groupInfo[group] = { type: 'pair', sets };",
"        sets.forEach((set, idx) => mapOptionsToGroup(set, group, idx));",
"      } else {",
"        const flatArr = arr.flat();",
"        groupInfo[group] = { type: 'exclusive', sets: [flatArr] };",
"        mapOptionsToGroup(flatArr, group, 0);",
"      }",
"    });",
"",
"    function mapOptionsToGroup(options, group, role) {",
"      options.forEach((code) => {",
"        if (!optionMap[code]) optionMap[code] = [];",
"        optionMap[code].push({ group, role });",
"      });",
"    }",
"",
"    question.addEventListener('change', updateDisabled);",
"",
"    function updateDisabled() {",
"      const checked = Object.keys(optionMap).filter((code) => {",
"        const input = document.querySelector(`#answer\\${qnum}-\\${code}`);",
"        return input && input.checked;",
"      });",
"      const answerWrapper = question.querySelectorAll(`.answer-choice-on-wrapper`);",
"      if (answerWrapper.length >= maxAnswer) {",
"        return;",
"      }",
"",
"      let hasConflict = false;",
"      const conflictGroups = new Set();",
"",
"      checked.forEach((checkedCode) => {",
"        optionMap[checkedCode].forEach(({ group, role }) => {",
"          const info = groupInfo[group];",
"",
"          if (info.type === 'exclusive') {",
"            const sameGroupChecked = checked.filter(",
"              (code) => code !== checkedCode && optionMap[code].some((x) => x.group === group)",
"            );",
"            if (sameGroupChecked.length > 0) {",
"              hasConflict = true;",
"              conflictGroups.add(group);",
"            }",
"          } else if (info.type === 'pair') {",
"            const agroupChecked = checked.filter((code) =>",
"              optionMap[code].some((x) => x.group === group && x.role === 0)",
"            );",
"            const bgroupChecked = checked.filter((code) =>",
"              optionMap[code].some((x) => x.group === group && x.role === 1)",
"            );",
"",
"            if (agroupChecked.length > 0 && bgroupChecked.length > 0) {",
"              hasConflict = true;",
"              conflictGroups.add(group);",
"            }",
"          }",
"        });",
"      });",
"",
"      if (hasConflict) {",
"        console.warn('중복 선택이 감지되어 해당 그룹의 응답을 초기화합니다.');",
"        resetConflictGroups(conflictGroups);",
"        return;",
"      }",
"",
"      Object.keys(optionMap).forEach((code) => {",
"        let shouldDisable = false;",
"",
"        optionMap[code].forEach(({ group, role }) => {",
"          const info = groupInfo[group];",
"",
"          if (info.type === 'exclusive') {",
"            checked.forEach((checkedCode) => {",
"              if (checkedCode !== code && optionMap[checkedCode].some((x) => x.group === group)) {",
"                shouldDisable = true;",
"              }",
"            });",
"          } else if (info.type === 'pair') {",
"            checked.forEach((checkedCode) => {",
"              optionMap[checkedCode].forEach(({ group: checkedGroup, role: checkedRole }) => {",
"                if (group === checkedGroup && role !== checkedRole) {",
"                  shouldDisable = true;",
"                }",
"              });",
"            });",
"          }",
"        });",
"",
"        const input = document.querySelector(`#answer\\${qnum}-\\${code}`);",
"        const option = input?.parentNode;",
"",
"        if (input && option) {",
"          input.readOnly = shouldDisable;",
"          option.style.opacity = shouldDisable ? '0.5' : '1';",
"          option.style.pointerEvents = shouldDisable ? 'none' : '';",
"        }",
"      });",
"    }",
"",
"    function resetConflictGroups(conflictGroups) {",
"      Object.keys(optionMap).forEach((code) => {",
"        const belongsToConflictGroup = optionMap[code].some(({ group }) => conflictGroups.has(group));",
"",
"        if (belongsToConflictGroup) {",
"          const input = document.querySelector(`#answer\\${qnum}-\\${code}`);",
"          const option = input?.parentNode;",
"",
"          if (input && option) {",
"            turn_off_checkbox(\\$(option));",
"",
"            input.readOnly = false;",
"",
"            option.style.opacity = '1';",
"            option.style.pointerEvents = '';",
"          }",
"        }",
"      });",
"    }",
"",
"    updateDisabled();",
"  } catch (e) {",
"    console.error('Error in thisOrThat function:', e);",
"  } finally {",
"    return true;",
"  }",
"};"
    ],
    "description": "[사전 로직] thisOrThat 함수 (보기간 중복 선택 불가)"
  },
  "validateLogics": {
    "prefix": "pre-vali",
    "scope": "js",
    "body": [
      "window.exec = (fn) => {",
      "  try {",
      "    fn();",
      "  } catch (error) {",
      "    console.error(error);",
      "  } finally {",
      "    return true;",
      "  }",
      "};",
      "",
      "window.cond = (fn) => {",
      "  try {",
      "    return fn();",
      "  } catch (error) {",
      "    console.error(error);",
      "    return true;",
      "  }",
      "};",
      "",
      "window.err = (msg) => {",
      "  alert(msg);",
      "  return true;",
      "};",
      "",
      "window.softFlag = true;",
      "window.softErr = (msg) => {",
      "  if (window.softFlag) {",
      "    alert(msg);",
      "    window.softFlag = false;",
      "    return true;",
      "  } else {",
      "    window.softFlag = true;",
      "    return false;",
      "  }",
      "};",
      "",
      "window.validate = (fn, target = null) => {",
      "  const wrappedFn = () => {",
      "    try {",
      "      const result = fn();",
      "      return result;",
      "    } catch (error) {",
      "      return false;",
      "    }",
      "  };",
      "",
      "  return exec(() => {",
      "    if (target !== null && typeof target !== 'number') {",
      "      throw new Error('target must be a number');",
      "    }",
      "",
      "    let qNumber = target;",
      "    if (qNumber === null) {",
      "      qNumber = cur;",
      "    }",
      "",
      "    if (typeof fn !== 'function') {",
      "      throw new Error('fn must be a function');",
      "    }",
      "",
      "    const targetQuestion = document.querySelector(`#survey\\${qNumber}`);",
      "    const targetBtn = targetQuestion.querySelector('.next-btn-wrapper');",
      "    targetBtn.removeAttribute('onclick');",
      "    targetBtn.onclick = null;",
      "",
      "    targetBtn.addEventListener('click', () => {",
      "      const validateResult = wrappedFn();",
      "",
      "      if (validateResult === true) {",
      "        return;",
      "      } else {",
      "        goNext();",
      "      }",
      "    });",
      "  });",
      "};",
      "",
      "window.hangle = (qnum = null) => {",
      "  if (qnum === null) {",
      "    qnum = cur;",
      "  }",
      "",
      "  validate(() => {",
      "    const textAnswers = document.querySelectorAll(`#survey\\${qnum} input[type='text'], #survey\\${qnum} textarea`);",
      "    const badAnswer = [...textAnswers].some((answer) => {",
      "      return answer.value.match(/[ㄱ-ㅎㅏ-ㅣ]/);",
      "    });",
      "    if (badAnswer) {",
      "      return err('자/모음이 입력된 답변이 있습니다.');",
      "    }",
      "  });",
      "",
      "  return true;",
      "};"
    ],
    "description": "[사전 로직] exec/cond/validate/hangle"
  },
  "replaceTextFunction": {
    "prefix": "pre-rpt",
    "scope": "js",
    "body": [
      "window.replaceText = (replacements, qnum = null) => {",
      "  try {",
      "    if (qnum === null) {",
      "      qnum = cur;",
      "    }",
      "    const question = document.querySelector(`#survey\\${qnum}`);",
      "    if (!question) {",
      "      throw new Error(`Q\\${qnum} is not found`);",
      "    }",
      "",
      "    const mainFnc = () => {",
      "      if (typeof replacements !== 'object' || replacements === null) {",
      "        throw new Error('replacements must be an object');",
      "      }",
      "",
      "      const answerEvalText = question.querySelectorAll('.answer-eval-text');",
      "      const answerLabel = question.querySelectorAll('.answer-label');",
      "      const description = question.querySelectorAll('.question-description');",
      "      const allElements = [...description, ...answerEvalText, ...answerLabel];",
      "",
      "      for (const [key, conditions] of Object.entries(replacements)) {",
      "        const pattern = new RegExp(`{{\\${key}}}`, 'g');",
      "        const baseClass = `replace-\\${key.toLowerCase()}`;",
      "        let changeText = conditions;",
      "        if (typeof conditions === 'object' && conditions !== null) {",
      "          const pipe = Object.entries(conditions).find(([key, value]) => value === true);",
      "          if (!pipe || pipe.length === 0) {",
      "            changeText = 'UNDEFINED';",
      "          } else {",
      "            changeText = pipe[0];",
      "          }",
      "        } else {",
      "          changeText = conditions;",
      "        }",
      "",
      "        allElements.forEach((element) => {",
      "          const replaceBase = element.querySelectorAll(`.\\${baseClass}`);",
      "          if (replaceBase.length >= 1) {",
      "            replaceBase.forEach((base) => {",
      "              base.innerHTML = changeText;",
      "            });",
      "          } else {",
      "            const replaceSpan = document.createElement('span');",
      "            replaceSpan.classList.add(baseClass);",
      "            replaceSpan.innerHTML = changeText;",
      "",
      "            element.innerHTML = element.innerHTML.replace(pattern, function () {",
      "              return replaceSpan.outerHTML;",
      "            });",
      "          }",
      "        });",
      "      }",
      "    };",
      "",
      "    const originReferAnswers = window.referAnswers;",
      "    function referAnswersWrapper(fn) {",
      "      return function (...args) {",
      "        const result = fn.apply(this, args);",
      "        mainFnc();",
      "        return result;",
      "      };",
      "    }",
      "",
      "    window.referAnswers = referAnswersWrapper(window.referAnswers);",
      "    referAnswers(qnum);",
      "    common_align(qnum);",
      "",
      "    const nxtBtn = document.querySelector(`#survey\\${qnum} .next-btn-wrapper`);",
      "    nxtBtn.addEventListener('click', () => {",
      "      window.referAnswers = originReferAnswers;",
      "    });",
      "  } catch (error) {",
      "    console.error(error);",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 텍스트 파이핑 로직"
  },
  "shuffleByFunction": {
    "prefix": "pre-shb",
    "scope": "js",
    "body": [
      "window.shuffleBy = (baseQid, qnum = null) => {",
      "  const params = { baseQid, qnum };",
      "  for (const [key, value] of Object.entries(params)) {",
      "    if (value === null && key === 'qnum') continue;",
      "    if (typeof value !== 'number') {",
      "      throw new Error(`Please set '\\${key}' as a number`);",
      "    }",
      "  }",
      "",
      "  if (qnum === null) {",
      "    qnum = cur;",
      "  }",
      "",
      "  try {",
      "    const answerWrappers = '.answer-wrapper .answer-choice-wrapper';",
      "    const baseQuestion = `#survey\\${baseQid} \\${answerWrappers}`;",
      "    const targetQuestion = `#survey\\${qnum} \\${answerWrappers}`;",
      "",
      "    const answerWrapper = document.querySelector(`#survey\\${qnum} .answer-wrapper`);",
      "",
      "    const baseQuestionAnswers = document.querySelectorAll(baseQuestion);",
      "    const answerOrderValues = [...baseQuestionAnswers].map((ans) => ans.querySelector(`input[id^='rank']`).value);",
      "",
      "    const targetQuestionAnswers = document.querySelectorAll(targetQuestion);",
      "    const targetAnswers = [...targetQuestionAnswers];",
      "    const targetAnswerValues = targetAnswers.map((ans) => ans.querySelector(`input[id^='rank']`).value);",
      "",
      "    const remainAnswers = targetAnswerValues.filter((value) => !answerOrderValues.includes(value) && value !== '-1');",
      "    if (remainAnswers.length > 0) {",
      "      throw new Error(`There are mismatched answers. : \\${remainAnswers}`);",
      "    }",
      "",
      "    try {",
      "      const tempContainer = document.createDocumentFragment();",
      "",
      "      while (answerWrapper.firstChild) {",
      "        tempContainer.appendChild(answerWrapper.firstChild);",
      "      }",
      "",
      "      answerOrderValues.forEach((rank) => {",
      "        try {",
      "          const matchingAnswer = targetAnswers.find(",
      "            (wrapper) => wrapper.querySelector(`input[id^='rank']`).value === rank",
      "          );",
      "          if (matchingAnswer) {",
      "            answerWrapper.appendChild(matchingAnswer);",
      "          }",
      "        } catch (error) {",
      "          console.error('Error reordering answers:', error);",
      "          throw error;",
      "        }",
      "      });",
      "",
      "      while (tempContainer.firstChild) {",
      "        answerWrapper.appendChild(tempContainer.firstChild);",
      "      }",
      "",
      "      if (typeof updateQASummary === 'function') {",
      "        updateQASummary(qnum, `shb: Q\\${baseQid}`);",
      "      }",
      "    } catch (error) {",
      "      console.error('Error relocating answers:', error);",
      "      throw error;",
      "    }",
      "  } catch (error) {",
      "    console.error('shuffleBy Function Errors:', error);",
      "    throw error;",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 특정 문항 기준 로테이션 순서 동일 설정"
  },
  "holdNext": {
    "prefix": "pre-timer",
    "scope": "js",
    "body": [
      "window.holdNext = ({ seconds = 5, qnum = null, mode = 'count' } = {}) => {",
      "  try {",
      "    if (qnum === null) {",
      "      qnum = cur;",
      "    }",
      "    const question = document.querySelector(`#survey\\${qnum}`);",
      "    if (!question) {",
      "      throw new Error(`Q\\${qnum} is not found`);",
      "    }",
      "",
      "    const wrapper = question.querySelector('.next-btn-wrapper');",
      "    const target = wrapper.querySelector('.next');",
      "",
      "    if (mode === 'count') {",
      "      const originNextText = target.textContent;",
      "      wrapper.style.pointerEvents = 'none';",
      "      let remainingSeconds = seconds;",
      "      target.textContent = remainingSeconds;",
      "",
      "      const countdownInterval = setInterval(() => {",
      "        remainingSeconds--;",
      "        if (remainingSeconds > 0) {",
      "          target.textContent = remainingSeconds;",
      "        } else {",
      "          clearInterval(countdownInterval);",
      "          target.textContent = originNextText;",
      "          wrapper.style.pointerEvents = 'auto';",
      "        }",
      "      }, 1000);",
      "    } else if (mode === 'alert') {",
      "      const message = '더 자세히 확인하고 응답해 주세요.';",
      "      wrapper.setAttribute('onclick', `alert('\\${message}')`);",
      "      setTimeout(() => {",
      "        wrapper.setAttribute('onclick', 'goNext()');",
      "      }, seconds * 1000);",
      "    } else if (mode === 'blur') {",
      "      wrapper.style.pointerEvents = 'none';",
      "      wrapper.style.opacity = '0.5';",
      "      setTimeout(() => {",
      "        wrapper.style.pointerEvents = 'auto';",
      "        wrapper.style.opacity = '1';",
      "      }, seconds * 1000);",
      "    }",
      "  } catch (error) {",
      "    console.error(error);",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 다음 버튼 홀딩 (count/alert/blur)"
  },
  "groupRotationFunction": {
    "prefix": "pre-gr-rot",
    "scope": "js",
    "body": [
      "window.groupRotation = (optionGroups = [], config = {}, qnum = null) => {",
      "  config.group = config.group !== undefined ? config.group : true;",
      "  config.option = config.option !== undefined ? config.option : true;",
      "  try {",
      "    if (qnum === null) {",
      "      qnum = cur;",
      "    }",
      "",
      "    if (optionGroups.length === 0) return true;",
      "    if (optionGroups.some((group) => !Array.isArray(group))) {",
      "      throw new Error('optionGroups must be an array of arrays');",
      "    }",
      "",
      "    const { group: groupRandom, option: optionRandom } = config;",
      "    const question = document.querySelector(`#survey\\${qnum}`);",
      "    const originOrder = [...question.querySelectorAll('.answer-choice-wrapper')];",
      "    let options = [];",
      "    let fixed = [];",
      "",
      "    originOrder.forEach((e) => {",
      "      const rank = Number(e.querySelector('#rank').value);",
      "      if (e.classList.contains('answer-etc') || rank === -1) {",
      "        fixed.push(rank);",
      "      } else {",
      "        options.push(rank);",
      "      }",
      "    });",
      "",
      "    options = options.sort((a, b) => a - b);",
      "",
      "    let newOrders = [];",
      "",
      "    for (const groups of optionGroups) {",
      "      const setGroup = options.filter((e) => groups.includes(e));",
      "      if (optionRandom) {",
      "        setGroup.sort(() => Math.random() - 0.5);",
      "      }",
      "      options = options.filter((e) => !groups.includes(e));",
      "      newOrders.push(setGroup);",
      "    }",
      "",
      "    if (options.length > 0) {",
      "      options.forEach((code) => {",
      "        newOrders.push([code]);",
      "      });",
      "    }",
      "",
      "    if (groupRandom) {",
      "      newOrders.sort(() => Math.random() - 0.5);",
      "    }",
      "",
      "    const answerWrapper = question.querySelector('.answer-wrapper');",
      "    newOrders.forEach((order) => {",
      "      order.forEach((code) => {",
      "        const optionNode = originOrder.find((e) => e.querySelector('#rank').value === String(code));",
      "        if (optionNode) {",
      "          answerWrapper.appendChild(optionNode);",
      "        } else {",
      "          console.warn(`Option with rank \\${code} not found`);",
      "        }",
      "      });",
      "    });",
      "",
      "    if ('top' in config) {",
      "      const top = config.top;",
      "      if (!Array.isArray(top)) throw new Error('top must be an array');",
      "",
      "      const topShuffle = config.topShuffle ?? true;",
      "      if (topShuffle) top.sort(() => Math.random() - 0.5);",
      "",
      "      [...top].reverse().forEach((code) => {",
      "        const optionNode = originOrder.find((e) => e.querySelector('#rank').value === String(code));",
      "        optionNode",
      "          ? answerWrapper.insertBefore(optionNode, answerWrapper.firstChild)",
      "          : console.warn(`Top : Option with rank \\${code} not found`);",
      "      });",
      "    }",
      "",
      "    if ('bot' in config) {",
      "      const bot = config.bot;",
      "      if (!Array.isArray(bot)) throw new Error('bottom must be an array');",
      "",
      "      const botShuffle = config.botShuffle ?? true;",
      "      if (botShuffle) bot.sort(() => Math.random() - 0.5);",
      "",
      "      bot.forEach((code) => {",
      "        const optionNode = originOrder.find((e) => e.querySelector('#rank').value === String(code));",
      "        optionNode ? answerWrapper.appendChild(optionNode) : console.warn(`Bot : Option with rank \\${code} not found`);",
      "      });",
      "    }",
      "",
      "    fixed.forEach((code) => {",
      "      const optionNode = originOrder.find((e) => e.querySelector('#rank').value === String(code));",
      "      if (optionNode) {",
      "        answerWrapper.appendChild(optionNode);",
      "      }",
      "    });",
      "  } catch (e) {",
      "    console.error(e);",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 응답 보기 그룹 로테이션 (groupRotation)"
  },
  "betweenFunction": {
    "prefix": "pre-bt",
    "scope": "js",
    "body": [
      "window.between = (start, end) => {",
      "  return Array.from({ length: end - start + 1 }, (_, i) => start + i);",
      "};"
    ],
    "description": "[사전 로직] 특정 범위 배열 반환 함수 (between)"
  },
  "optionPosition": {
    "prefix": "pre-opt-pos",
    "scope": "js",
    "body": [
      "const optionPosition = (baseCode, appendCodes, qnum, isNext) => {",
      "  try {",
      "    if (qnum === null) {",
      "      qnum = cur;",
      "    }",
      "    if (baseCode === null) {",
      "      throw new Error('baseCode is required');",
      "    }",
      "",
      "    if (!Array.isArray(appendCodes)) {",
      "      appendCodes = [appendCodes];",
      "    }",
      "",
      "    if (isNext) {",
      "      appendCodes = appendCodes.reverse();",
      "    }",
      "",
      "    appendCodes.forEach((code) => {",
      "      const base = document.querySelector(`#answer\\${qnum}-\\${baseCode}`).parentNode;",
      "      const target = document.querySelector(`#answer\\${qnum}-\\${code}`).parentNode;",
      "      base.parentNode.insertBefore(target, isNext ? base.nextSibling : base);",
      "    });",
      "  } catch (e) {",
      "    console.error(e);",
      "  } finally {",
      "    return true;",
      "  }",
      "};",
      "",
      "window.nextTo = (baseCode = null, appendCodes = [], qnum = null) => {",
      "  return optionPosition(baseCode, appendCodes, qnum, true);",
      "};",
      "",
      "window.beforeTo = (baseCode = null, appendCodes = [], qnum = null) => {",
      "  return optionPosition(baseCode, appendCodes, qnum, false);",
      "};",
      "",
      "window.topPosition = (appendCodes = [], qnum = null) => {",
      "  try {",
      "    if (qnum === null) {",
      "      qnum = cur;",
      "    }",
      "",
      "    if (!Array.isArray(appendCodes)) {",
      "      appendCodes = [appendCodes];",
      "    }",
      "",
      "    appendCodes = appendCodes.reverse();",
      "",
      "    const base = document.querySelector(`#survey\\${qnum} .answer-wrapper`);",
      "    appendCodes.forEach((code) => {",
      "      const target = document.querySelector(`#answer\\${qnum}-\\${code}`).parentNode;",
      "      if (target) {",
      "        base.insertBefore(target, base.firstChild);",
      "      }",
      "    });",
      "  } catch (e) {",
      "    console.error(e);",
      "  } finally {",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 보기를 특정 위치로 이동 (next/before/top)"
  },
  "sameRotationOrder": {
    "prefix": "pre-pipe-rot",
    "scope": "js",
    "body": [
      "// sameRotationOrder(문번호);",
      "function sameRotationOrder(setRotationBase, excludeNumbers = []) {",
      "  if (typeof setRotationBase !== 'number') {",
      "    throw new Error('Please set `setRotationBase` as a number');",
      "  }",
      "  if (!Array.isArray(excludeNumbers)) {",
      "    throw new Error('Please set `excludeNumbers` as an array');",
      "  } else {",
      "    excludeNumbers.forEach((number) => {",
      "      if (typeof number !== 'number') {",
      "        throw new Error('Please set `excludeNumbers` as an array of numbers');",
      "      }",
      "    });",
      "  }",
      "",
      "  const getPipingQuestions = (qnumber) => {",
      "    try {",
      "      const surveyForm = document.querySelector('#survey_form');",
      "      const questions = surveyForm.querySelectorAll('.survey');",
      "      return [...questions].filter((q) => Number(q.querySelector('#pipingParent').value) === qnumber);",
      "    } catch (error) {",
      "      console.error('getPipingQuestions function error:', error);",
      "      throw error;",
      "    }",
      "  };",
      "",
      "  const getQuestionNumber = (question) => {",
      "    return Number(question.id.replace(/[^0-9]/g, ''));",
      "  };",
      "",
      "  try {",
      "    const isDiffAnswer = (answer) => {",
      "      try {",
      "        return !answer.querySelector('.answer-etc') && answer.querySelector(`input[id^='rank']`).value !== '-1';",
      "      } catch (error) {",
      "        console.error('isDiffAnswer function error:', error);",
      "        throw error;",
      "      }",
      "    };",
      "",
      "    const findAllPipingQuestions = (baseQid, processedQids = new Set(), result = []) => {",
      "      try {",
      "        if (processedQids.has(baseQid)) return result;",
      "",
      "        processedQids.add(baseQid);",
      "        const pipingQuestions = getPipingQuestions(baseQid);",
      "",
      "        if (pipingQuestions.length > 0) {",
      "          result.push(...pipingQuestions);",
      "",
      "          pipingQuestions.forEach((question) => {",
      "            findAllPipingQuestions(getQuestionNumber(question), processedQids, result);",
      "          });",
      "        }",
      "",
      "        return result;",
      "      } catch (error) {",
      "        console.error('findAllPipingQuestions function error:', error);",
      "        throw error;",
      "      }",
      "    };",
      "",
      "    try {",
      "      const setRotationQuestions = findAllPipingQuestions(setRotationBase);",
      "",
      "      const answerWrappers = '.answer-wrapper .answer-choice-wrapper';",
      "      const baseQuestionAnswers = document.querySelectorAll(`#survey\\${setRotationBase} \\${answerWrappers}`);",
      "",
      "      const filteredAnswers = [...baseQuestionAnswers].filter(isDiffAnswer);",
      "      const answerOrderValues = filteredAnswers.map((ans) => ans.querySelector(`input[id^='rank']`).value);",
      "",
      "      setRotationQuestions.forEach((question) => {",
      "        try {",
      "          const questionNumber = getQuestionNumber(question);",
      "          if (excludeNumbers.includes(questionNumber)) {",
      "            console.log(`Q\\${questionNumber} > Random Rotation`);",
      "            return;",
      "          }",
      "",
      "          const answerWrapper = question.querySelector('.answer-wrapper');",
      "          const currentAnswers = [...question.querySelectorAll(answerWrappers)];",
      "",
      "          const etcAnswers = currentAnswers.filter((ans) => !isDiffAnswer(ans));",
      "          const normalAnswers = currentAnswers.filter(isDiffAnswer);",
      "",
      "          const tempContainer = document.createDocumentFragment();",
      "",
      "          answerOrderValues.forEach((rank) => {",
      "            try {",
      "              const matchingAnswer = normalAnswers.find(",
      "                (wrapper) => wrapper.querySelector(`input[id^='rank']`).value === rank",
      "              );",
      "              if (matchingAnswer) {",
      "                tempContainer.appendChild(matchingAnswer);",
      "              }",
      "            } catch (error) {",
      "              console.error('Error adjusting answer order:', error);",
      "              throw error;",
      "            }",
      "          });",
      "",
      "          etcAnswers.forEach((ans) => tempContainer.appendChild(ans));",
      "",
      "          answerWrapper.appendChild(tempContainer);",
      "        } catch (error) {",
      "          console.error('Error processing question:', error);",
      "          throw error;",
      "        }",
      "      });",
      "    } catch (error) {",
      "      console.error('Error in main logic processing:', error);",
      "      throw error;",
      "    }",
      "  } catch (error) {",
      "    console.error('sameRotationOrder function error:', error);",
      "    throw error;",
      "  }",
      "};"
    ],
    "description": "[사전 로직] 파이핑 로직 적용 문항 로테이션 통일"
  },
  "arrowFunctionReturnTrue": {
    "prefix": "fnc",
    "scope": "js",
    "body": ["(()=>{", "    ${1}", "    return true;", "})()"],
    "description": "Arrow Function"
  },
  "groupRotation": {
    "prefix": "gr",
    "scope": "js",
    "body": ["groupRotation([", "    [group1],", "    [group2],", "])"],
    "description": "groupRotation"
  },
  "groupRotationWithBot": {
    "prefix": "gr-bot",
    "scope": "js",
    "body": [
      "groupRotation([",
      "    [group1],",
      "    [group2],",
      "], {",
      "    bot: [Bottom],",
      "    botShuffle: true,",
      "})"
    ],
    "description": "groupRotation with bottom"
  },
  "groupRotationWithTop": {
    "prefix": "gr-top",
    "scope": "js",
    "body": [
      "groupRotation([",
      "    [group1],",
      "    [group2],",
      "], {",
      "    top: [top],",
      "    topShuffle: true,",
      "})"
    ],
    "description": "groupRotation with top"
  },
  "groupRotationWithAll": {
    "prefix": "gr-all",
    "scope": "js",
    "body": [
      "groupRotation([",
      "    [group1],",
      "    [group2],",
      "], {",
      "    top: [top],",
      "    topShuffle: true,",
      "    bot: [bottom],",
      "    botShuffle: true,",
      "})"
    ],
    "description": "groupRotation with top/bottom"
  },
  "thisOrThat": {
    "prefix": "tot",
    "scope": "js",
    "body": ["thisOrThat({", "    g1: [group1],", "})"],
    "description": "thisOrThat function"
  },
  "getAnswerSet": {
    "prefix": "ga",
    "scope": "js",
    "body": ["getAnswerSet(${1:qid})"],
    "description": "getAnswerSet snippet"
  },
  "getAnswerSetAnswersSingleCode": {
    "prefix": "ans",
    "scope": "js",
    "body": ["getAnswerSet(${1:qid}).answers[0].value.order"],
    "description": "Get Single Answer Code"
  },
  "getAnswerSetAnswersCodes": {
    "prefix": "answers",
    "scope": "js",
    "body": ["getAnswerSet(${1:qid}).answers.map(ans => ans.value.order)"],
    "description": "getAnswerSet snippet"
  },
  "radioAutoPunching": {
    "prefix": "sa-auto",
    "scope": "js",
    "body": [
      "(() => {",
      "  /* 오토펀칭 코드 */",
      "  const autoCode = ${1:1};",
      "",
      "  /* 테스트 하는 동안 주석 */",
      "  // hideOption(cur);",
      "  // showOption(cur, [autoCode]);",
      "",
      "  const attr = \\$(`#survey\\${cur} #answer\\${cur}-\\${autoCode}`);",
      "  turn_on_radio(attr.parent());",
      "",
      "  /* 실사시에는 goNext() 주석 해제 */",
      "  // goNext();",
      "  return true;",
      "})()"
    ],
    "description": "객관식 단수 오토펀치"
  },
  "checkboxAutoPunching": {
    "prefix": "ma-auto",
    "scope": "js",
    "body": [
      "(() => {",
      "  // 오토펀치할 코드를 배열로",
      "  const answers = [${1}];",
      "  /* 테스트 하는 동안 주석 */",
      "  hideOption(cur);",
      "  showOption(cur, answers);",
      "",
      "  answers.forEach((ans) => {",
      "    const attr = \\$(`#answer\\${cur}-\\${ans}`);",
      "    attr.prop('checked', true);",
      "  });",
      "",
      "  /* 실사전 goNext() 주석 제거 */",
      "  // goNext();",
      "  return true;",
      "})()"
    ],
    "description": "객관식 복수 오토펀치"
  },
  "shuffleBy": {
    "prefix": "shb",
    "scope": "js",
    "body": ["shuffleBy(${1:qid})"],
    "description": "shuffleBy"
  },
  "getRanks": {
    "prefix": "ranks",
    "scope": "js",
    "body": ["[...\\$(`#survey\\${cur} .answer-choice-wrapper #rank`)].map((e) => Number(e.value))"],
    "description": "객관식의 보기의 코드를 배열로 담는 코드"
  },
  "hideOption": {
    "prefix": "hide",
    "scope": "js",
    "body": ["hideOption(cur)"],
    "description": "hideOption"
  },
  "showOption": {
    "prefix": "show",
    "scope": "js",
    "body": ["showOption(cur)"],
    "description": "showOption"
  },
  "imageSetting": {
    "prefix": "set-img",
    "scope": "js",
    "body": [
      "(() => {",
      "  const concepts = {",
      "    1: 'IMAGE URL 1',",
      "    2: 'IMAGE URL 2',",
      "  };",
      "",
      "  const allQuestions = [...\\$(`.survey .question-description`)];",
      "  allQuestions.forEach((question) => {",
      "    Object.entries(concepts).forEach(([concept, url]) => {",
      "      const replaceText = `{{CONCEPT_\\${concept}}}`;",
      "      const html = question.innerHTML;",
      "      if (!html.includes(replaceText)) {",
      "        return;",
      "      }",
      "      const img = `<img style=\"width: 100%;\" src=\"\\${url}\" alt=\"CONCEPT_\\${concept}\" />`;",
      "      question.innerHTML = html.replace(replaceText, img);",
      "    });",
      "  });",
      "",
      "  const answerLabels = [...\\$(`.survey .answer-wrapper .answer-label`)];",
      "  answerLabels.forEach((label) => {",
      "    Object.entries(concepts).forEach(([concept, url]) => {",
      "      const replaceText = `{{CONCEPT_\\${concept}}}`;",
      "      const html = label.innerHTML;",
      "      if (!html.includes(replaceText)) {",
      "        return;",
      "      }",
      "      const img = `<div class=\"answer-choice-img\" style=\"width: 100%;\"><img style=\"width: 100%;\" src=\"\\${url}\" alt=\"CONCEPT_\\${concept}\" /></div>`;",
      "      label.innerHTML = html.replace(replaceText, img);",
      "    });",
      "  });",
      "",
      "  return true;",
      "})()"
    ],
    "description": "이미지 일괄 처리"
  },
  "setETCAnswer": {
    "prefix": "etc",
    "scope": "js",
    "body": [
      "const etc = ${1:code}; // 기타 보기",
      "const label = \\$(`#answer\\${cur}-\\${etc}`).parent().find('.answer-label .fr-tag');",
      "const etcAnswer = getAnswerSet(${2:qid}).answers.find((ans) => ans.value.order === etc);",
      "if( etcAnswer ){",
      "    label.text(etcAnswer.value.alternative);",
      "}"
    ],
    "description": "기타 응답 참조 관련"
  },
  "setETCAnswerCond": {
    "prefix": "etc-raw",
    "scope": "js",
    "body": [
      "(Q${1:x}A${2:y}",
      "? \\$(`#survey\\${cur} label[for=answer\\${cur}-${2:y}] .fr-tag`).html(",
      "    getAnswerSet(${3:qid}).answers.find((e) => { return e.value.order == ${2:y};}).value.alternative",
      ")",
      ": true)"
    ],
    "description": "기타 응답 참조 로직 (3항 연산자)"
  },
  "between": {
    "prefix": "bt",
    "scope": "js",
    "body": ["between(${1:start}, ${2:end})"],
    "description": "between"
  },
  "thisOrThatWithGroup": {
    "prefix": "tot-group",
    "scope": "js",
    "body": [
      "(()=>{",
      "    const groups = {",
      "      g1: between(${1:start}, ${2:end}),",
      "    }",
      "    groupRotation(Object.values(groups));",
      "    thisOrThat(groups);",
      "    return true;",
      "})()"
    ],
    "description": "thisOrThat with Group Rotation"
  },
  "statusScreenOut": {
    "prefix": "scr",
    "scope": "js",
    "body": [
      "const redirect = {",
      "  // Redirect URL",
      "  screenout: `https://SCREENOUT_URL.com`,",
      "  complete: `https://COMPLETE_URL.com`,",
      "  quotafull: `https://QUOTAFULL_URL.com`,",
      "};",
      "",
      "const quotaFlag = \\$(`#quotaFlag`);",
      "const redirectUrl = \\$(`#redirectUrl`);",
      "",
      "/* 기본 스크린 아웃 설정 */",
      "quotaFlag.val(1);",
      "redirectUrl.val(window.redirect.screenout);",
      "setAnswer(1, ValueType.TEXT, 1, true);"
    ],
    "description": "[리다이렉트:ScreenOut] (사전 로직) 문항 기준 쿼터 세팅시 Status 변경 로직"
  },
  "statusOverQuota": {
    "prefix": "over",
    "scope": "js",
    "body": [
      "(() => {",
      "  // QuotaFull",
      "  \\$('#quotaFlag').val(3);",
      "  \\$('#redirectUrl').val(window.redirect.quotafull);",
      "  setAnswer(1, ValueType.TEXT, 3, true);",
      "  ${1}",
      "  return true;",
      "})()"
    ],
    "description": "[리다이렉트:OverQuota] (최초 쿼터 문항) 문항 기준 쿼터 세팅시 Status 변경 로직"
  },
  "statusComplete": {
    "prefix": "comp",
    "scope": "js",
    "body": [
      "(() => {",
      "  // Complete",
      "  \\$('#quotaFlag').val(2);",
      "  \\$('#redirectUrl').val(window.redirect.complete);",
      "  setAnswer(1, ValueType.TEXT, 2, true);",
      "  return true;",
      "})()"
    ],
    "description": "[리다이렉트:Complete] (본설문 진입 문항) 문항 기준 쿼터 세팅시 Status 변경 로직"
  },
  "replaceText": {
    "prefix": "rpt",
    "scope": "js",
    "body": ["replaceText({", "  ${1:KEY}: ${2:text}", "});"],
    "description": "replaceText"
  },
  "getNumberQuestion": {
    "prefix": "num",
    "scope": "js",
    "body": ["$(`#number\\${cur}`)"],
    "description": "주관식 숫자 jQuery 선택자"
  },
  "getOpenQuestion": {
    "prefix": "oe",
    "scope": "js",
    "body": ["$(`#answer\\${cur}`)"],
    "description": "주관식 jQuery 선택자 (Open Ended)"
  },
  "arrayFilterMethod": {
    "prefix": "filt",
    "scope": "js",
    "body": ["filter((${1:e}) => ${1:e}${2})"],
    "description": "Array filter method"
  },
  "arrayMapMethod": {
    "prefix": "map",
    "scope": "js",
    "body": ["map((${1:e}) => ${1:e})"],
    "description": "Array map method"
  },
  "arrayReduceMethod": {
    "prefix": "red",
    "scope": "js",
    "body": ["reduce((${1:acc}, ${2:cur}) => ${1:acc} + ${2:cur}, ${3:0})"],
    "description": "Array reduce method"
  },
  "arrayForEachMethod": {
    "prefix": "each",
    "scope": "js",
    "body": ["forEach((${1:e}) => ${2:console.log(${1:e})})"],
    "description": "Array forEach method"
  },
  "arrayFindMethod": {
    "prefix": "find",
    "scope": "js",
    "body": ["find((${1:e}) => ${1:e}${2})"],
    "description": "Array find method"
  },
  "arraySomeMethod": {
    "prefix": "some",
    "scope": "js",
    "body": ["some((${1:e}) => ${1:e}${2})"],
    "description": "Array some method"
  },
  "arrayEveryMethod": {
    "prefix": "every",
    "scope": "js",
    "body": ["every((${1:e}) => ${1:e}${2})"],
    "description": "Array every method"
  },
  "objectKeysMethod": {
    "prefix": "keys",
    "scope": "js",
    "body": ["Object.keys(${1:obj}).forEach((${2:key}) => ${3:console.log(${2:key})})"],
    "description": "Object keys method"
  },
  "objectValuesMethod": {
    "prefix": "values",
    "scope": "js",
    "body": ["Object.values(${1:obj}).forEach((${2:value}) => ${3:console.log(${2:value})})"],
    "description": "Object values method"
  },
  "objectEntriesMethod": {
    "prefix": "items",
    "scope": "js",
    "body": ["Object.entries(${1:obj}).forEach(([${2:key}, ${3:value}]) => ${4:console.log(${2:key}, ${3:value})})"],
    "description": "Object entries method"
  },
  "rating": {
    "prefix": "rating",
    "scope": "js",
    "body": ["rating({", "  reverse: ${1:false},", "  showValue: ${2:false},", "})"],
    "description": "rating 함수 (역순/점수 제시)"
  },
  "ratingWithFormat": {
    "prefix": "rating-for",
    "scope": "js",
    "body": ["rating({", "  reverse: ${1:false},", "  showValue: true,", "  format: ${2:'[%d점]'},", "})"],
    "description": "rating 함수 (점수 표기 포맷 변경)"
  },
  "ratingWithBalance": {
    "prefix": "rating-bal",
    "scope": "js",
    "body": ["rating({", "  balance: true,", "  format: ${1:'[%d]'},", "  colSpan: true,", "})"],
    "description": "rating 함수 (어의차이척도 점수 제시)"
  },

  "validateHard": {
    "prefix": "err",
    "scope": "js",
    "body": ["validate(()=>{", "  if( ${1:errorCond} ){", "    return err('ERROR MESSAGE');", "  }", "})"],
    "description": "[유효성 검증] 하드 에러메세지"
  },
  "validateSoft": {
    "prefix": "soft",
    "scope": "js",
    "body": ["validate(()=>{", "  if( ${1:errorCond} ){", "    return softErr('ERROR MESSAGE');", "  }", "})"],
    "description": "[유효성 검증] 소프트 에러메세지"
  },
  "sameQuestionRotationOrder": {
    "prefix": "pre-q-same",
    "scope": "js",
    "body": [
"const firstGroup = [${1}]; // 첫 번째 문항 로테이션 기준으로 작동",
"",
"const rotationIndex = firstGroup.map((v, index) => String(index));",
"// [window.conceptIndex]를 setGroupSet의 3번째 arg에 추가",
"window.conceptIndex = rotationIndex",
"  .map((value) => ({ value, sort: Math.random() }))",
"  .sort((a, b) => a.sort - b.sort)",
"  .map(({ value }) => value);",
"",
"",
"window.optionOrderSet = (indexOrder) => {",
"  const question = \\$(`#survey\\${cur}`);",
"  const answerWrappers = [...question.find(`.answer-choice-wrapper`)];",
"  const options = answerWrappers.filter((wrapper) => \\$(wrapper).find('input').val() !== '-1');",
"  const bottomOptions = answerWrappers.filter((wrapper) => \\$(wrapper).find('input').val() === '-1');",
"  const target = question.find('.answer-wrapper');",
"",
"  indexOrder.forEach((groupIndexStr) => {",
"    const groupIndex = Number(groupIndexStr);",
"    const option = options.find((opt) => Number(\\$(opt).find('input').val()) - 1 === groupIndex);",
"    if (option) {",
"      \\$(target).append(option);",
"    }",
"  });",
"",
"  bottomOptions.forEach((option) => {",
"    \\$(target).append(option);",
"  });",
"",
"  return true;",
"};"
    ],
    "description": "[사전 로직] 문항 로테이션 통일 / 보기 순서 통일"
  },
  "createImageDialog": {
    "prefix": "pre-dialog",
    "scope": "js",
    "body": [
"// Example",
"const images = {",
"  P: 'https://d270g2swf0nd4h.cloudfront.net/265919_q1.png',",
"  Q: 'https://d270g2swf0nd4h.cloudfront.net/263121_q2.gif',",
"};",
"",
"Object.entries(images).forEach(([key, src]) => {",
"  createImageDialog({ src, key: `dialog-\\${key}` });",
"});",
"",
"// 다이얼로그를 생성하는 함수",
"function createImageDialog({ src = null, key = null }) {",
"  if (src == null || key == null) return null;",
"",
"  const css = `",
"          .dialog-modal {",
"            padding: 0;",
"            border: none;",
"            border-radius: 0;",
"            max-width: 100vw;",
"            max-height: 100vh;",
"            width: 100%;",
"            height: 100%;",
"            background: white;",
"            opacity: 0;",
"            transition: opacity 0.3s ease-in-out;",
"            overflow-y: auto;",
"          }",
"          .dialog-modal::backdrop {",
"            background: white;",
"          }",
"          .dialog-modal.show {",
"            opacity: 1;",
"          }",
"",
"          .dialog-content {",
"            position: relative;",
"            width: 100%;",
"            min-height: 100vh;",
"            display: flex;",
"            align-items: center;",
"            justify-content: center;",
"            padding: 20px;",
"            box-sizing: border-box;",
"          }",
"          @media (max-width: 768px) {",
"            .dialog-content {",
"              padding: 0;",
"              width: 100vw;",
"              height: 100vh;",
"              min-height: 100vh;",
"            }",
"          }",
"",
"          .dialog-title {",
"            position: relative;",
"            width: 100%;",
"            max-width: 700px;",
"            display: flex;",
"            align-items: center;",
"            flex-direction: column;",
"          }",
"          @media (max-width: 768px) {",
"            .dialog-title {",
"              max-width: 100%;",
"              width: 100vw;",
"              height: 100vh;",
"            }",
"          }",
"",
"          .dialog-title h2 {",
"            display: none;",
"          }",
"",
"          .dialog-title img {",
"            width: 100%;",
"            height: auto;",
"            object-fit: contain;",
"            display: block;",
"          }",
"          @media (max-width: 768px) {",
"            .dialog-title img {",
"              width: 100%;",
"              height: auto;",
"              max-height: none;",
"              object-fit: contain;",
"              display: block;",
"            }",
"          }",
"",
"          .dialog-close {",
"            position: fixed;",
"            top: 32px;",
"            right: 32px;",
"            z-index: 2000;",
"            background: rgba(0, 0, 0, 0.7);",
"            color: white;",
"            border: none;",
"            display: flex;",
"            align-items: center;",
"            justify-content: center;",
"            cursor: pointer;",
"            font-size: 14px;",
"            font-weight: bold;",
"            transition: all 0.2s ease-in-out;",
"            padding: 5px;",
"            border-radius: 50%;",
"            width: 40px;",
"            height: 40px;",
"          }",
"          @media (max-width: 768px) {",
"            .dialog-close {",
"              top: 12px;",
"              right: 12px;",
"            }",
"          }",
"          .dialog-close:hover {",
"            background: rgba(0, 0, 0, 0.9);",
"          }",
"",
"          .dialog-open {",
"            background: #26a9df;",
"            color: white;",
"            border: none;",
"            border-radius: 8px;",
"            padding: 12px 24px;",
"            font-size: 14px;",
"            font-weight: 600;",
"            cursor: pointer;",
"            width: 100%;",
"            text-align: center;",
"            max-width: 200px;",
"            margin: 0 auto;",
"            margin-block: 3px;",
"            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);",
"            transition: all 0.2s ease-in-out;",
"            outline: none;",
"            position: relative;",
"            overflow: hidden;",
"          }",
"          .dialog-open:hover {",
"            background: #2196d4;",
"            box-shadow: 0 6px 12px -2px rgba(0, 0, 0, 0.15), 0 4px 8px -2px rgba(0, 0, 0, 0.1);",
"            transform: translateY(-1px);",
"          }",
"          .dialog-open:active {",
"            transform: translateY(0);",
"            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);",
"          }",
"          .dialog-open:focus-visible {",
"            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 0 0 3px rgba(38, 169, 223, 0.3);",
"          }",
"        `;",
"",
"  const dialog = \\$(`<dialog class='dialog-modal'>",
"            <div class='dialog-content'>",
"              <div class='dialog-title'>",
"                <h2>Dialog Title</h2>",
"                <img src='\\${src}'>",
"                <div class='dialog-close'>닫기</div>",
"              </div>",
"            </div>",
"          </dialog>`);",
"",
"  dialog.attr('id', key);",
"",
"  const styleKey = 'dialog-modal-styles';",
"  if (!\\$(`head style[data-key='\\${styleKey}']`).length) {",
"    \\$('head').append(`<style data-key='\\${styleKey}'>\\${css}</style>`);",
"  }",
"",
"  \\$(`#survey_form`).append(dialog);",
"",
"  const closeBtn = dialog.find('.dialog-close');",
"  closeBtn.on('click', () => {",
"    dialog[0].close();",
"    dialog.removeClass('show');",
"  });",
"}",
"",
"window.showImageDialog = ({",
"  key = null,",
"  seconds = 0,",
"  show = false,",
"  showBtn = false,",
"  autoNext = false,",
"  btnText = '이미지 확인',",
"  appendDOM = null,",
"  full = false,",
"  showCenter = false,",
"}) => {",
"  try {",
"    if (appendDOM !== null) {",
"      showBtn = true;",
"    }",
"",
"    if (!showBtn && !show) {",
"      show = true;",
"    }",
"",
"    const dialog = \\$(`#\\${key}`);",
"    if (!dialog) return true;",
"",
"    const closeBtn = dialog.find('.dialog-close');",
"    const rawText = closeBtn.text();",
"",
"    // 카운트다운 함수 분리",
"    const startCountdown = () => {",
"      closeBtn.css({",
"        pointerEvents: 'none',",
"      });",
"",
"      let remain = seconds;",
"      closeBtn.text(remain);",
"      const interval = setInterval(() => {",
"        remain--;",
"        closeBtn.text(remain);",
"      }, 1000);",
"",
"      setTimeout(() => {",
"        clearInterval(interval);",
"        closeBtn.text(rawText);",
"        closeBtn.css({",
"          pointerEvents: 'auto',",
"        });",
"      }, seconds * 1000);",
"    };",
"",
"    closeBtn.off('click');",
"",
"    if (autoNext) {",
"      closeBtn.on('click', () => {",
"        dialog[0].close();",
"        dialog.removeClass('show');",
"        const attr = \\$(`#answer\\${cur}-1`).parent();",
"        turn_on_radio(\\$(attr));",
"        goNext();",
"      });",
"    } else {",
"      closeBtn.on('click', () => {",
"        dialog[0].close();",
"        dialog.removeClass('show');",
"      });",
"    }",
"",
"    let countdownStarted = false;",
"",
"    if (show) {",
"      dialog.addClass('show');",
"      dialog[0].showModal();",
"",
"      if (seconds > 0 && (!showBtn || (showBtn && show))) {",
"        startCountdown();",
"        countdownStarted = true;",
"      }",
"    }",
"",
"    if (showBtn) {",
"      const question = \\$(`#survey\\${cur}`);",
"      const dialogOpenClass = `\\${key}-open`;",
"",
"      const openBtn = \\$(`<div class='\\${dialogOpenClass} dialog-open'>\\${btnText}</div>`);",
"      if (appendDOM === null) {",
"        appendDOM = question.find('.question-description');",
"      }",
"",
"      question.find(`.\\${dialogOpenClass}`).remove();",
"      appendDOM.append(openBtn);",
"",
"      question.on('click', (e) => {",
"        if (e.target.classList.contains(dialogOpenClass)) {",
"          dialog[0].showModal();",
"          dialog.addClass('show');",
"          if (seconds > 0 && !show && !countdownStarted) {",
"            startCountdown();",
"            countdownStarted = true;",
"          }",
"        }",
"      });",
"    }",
"",
"    // ADD CSS",
"    const appendCSS = (css) => {",
"      const styleKey = 'dialog-modal-styles';",
"      const \\$style = \\$(`head style[data-key='\\${styleKey}']`);",
"      if (\\$style.length) {",
"        \\$style.append(css);",
"      }",
"    };",
"",
"    if (full) {",
"      appendCSS(`",
"        @media (max-width: 768px) {",
"        #\\${key} .dialog-title img {",
"              width: 100vw;",
"              height: 100vh;",
"              max-height: 100vh;",
"            }",
"        }",
"      `);",
"      showCenter = true;",
"    }",
"",
"    if (showCenter) {",
"      appendCSS(`",
"        #\\${key} .dialog-title {",
"          justify-content: center;",
"        }",
"      `);",
"    }",
"  } catch (e) {",
"    console.error(e);",
"  } finally {",
"    return true;",
"  }",
"};",
    ],
    "description": "[사전 로직] 이미지 팝업 형태 제시 로직"
  },
  "dialogDefault": {
    "prefix": "dialog",
    "scope": "js",
    "body": ["showImageDialog({key: 'dialog-${1:KEY}'})"],
    "description": "[Dialog] 문항이 제시될 때 팝업 제시"
  },
  "dialogHolding": {
    "prefix": "dialog-hold",
    "scope": "js",
    "body": ["showImageDialog({key: 'dialog-${1:KEY}', seconds: ${2:5}})"],
    "description": "[Dialog] 팝업 홀딩 시간 설정"
  },
  "dialogShowButton": {
    "prefix": "dialog-btn",
    "scope": "js",
    "body": ["showImageDialog({key: 'dialog-${1:KEY}', showBtn: true})"],
    "description": "[Dialog] 팝업을 보여주는 버튼 추가"
  },
}
